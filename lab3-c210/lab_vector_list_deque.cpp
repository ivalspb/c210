//Стандартная библиотека шаблонов - STL 
	//Контейнеры стандартной библиотеки - vector
	//Итераторы

#include <iostream>
#include <vector>
#include <list>
#include "my_vector.h"
#include "my_container.h"
#include "myString.h"
#include "Point.h"

#pragma warning(disable: 4786)


using namespace std;	

#define	  stop __asm nop


int main()
{
	// Контейнер стандартной библиотеки vector 
	setlocale(LC_ALL, "Russian");
	//////////////////////////////////////////////////////////////////////
	//Создание векторов. 

	//Создайте следующие вектора:
	//---------------------------
	//пустой вектор целых чисел - vInt и проверьте с помощью функции size(),
	//что его размер нулевой. 
	vector<int> vInt;
	size_t s = vInt.size();
	
	
	//Раскомментируйте следующий фрагмент, подумайте - все ли корректно
	//Если есть некорректности, - исправьте
	vInt.push_back(0);
	vInt.front()=1;


	//С помощью функции push_back() в цикле заполните вектор какими-либо значениями.
	//На каждой итерации цикла следите за размером вектора с помощью методов
	//size(), capacity(), max_size() и выводите значения элементов. 
	//
	//Подсказка: так как такая проверка понадобится Вам и в следующих заданиях,
	//напишите шаблон функции, которая для вектора, содержащего элементы любого типа
	//выводит его "реквизиты" и значения элементов на консоль.
	for(size_t i=0;i<10;i++)
	{
		vInt.push_back(rand() % 100);
		printVector(vInt);
	}
	stop
	//вектор вещественных - vDouble1 с заданным Вами начальным размером  и
	//проверьте результат с помощью созданного Вами шаблона. Как будут
	//проинициализированы элементы вектора?
	vector<double> vDouble(10);
	printVector(vDouble);
	stop
		//вектор объектов типа MyString с начальным размером - 5 элементов
		//и инициализацией каждого элемента строкой "A"
		//C помощью функции at() а также с помощью оператора
		//индексирования []  измените значения каких-либо элементов.
		//Попробуйте "выйти" за границы вектора с помощью at() и
		//с помощью []. 

	vector<MyString> vMyString(5, "A");
	vMyString[2] = "Dbc";
	try {
		vMyString.at(3) = "Abc";
		printVector(vMyString);
//		vMyString.at(5) = "error!";
	//	printVector(vMyString);
//		vMyString[5] = "error!";
	//	printVector(vMyString);
	}
	catch (const exception& e)
	{
		cerr << endl << "Caught: " << e.what() << endl;
		cerr << "Type: " << typeid(e).name() << endl;
	}
	
	stop

		//вектор вещественных - vDouble3, который является копией элементов
		// [0,5) массива вещественных чисел dMas. Предворительно массив dMas 
		//нужно создать и проинициализировать!

	double dMas[5] = { 1,2,3,4,5 };
	vector<double>vDouble3(dMas, dMas + sizeof(dMas)/sizeof(dMas[0]));
	printVector(vDouble3);
	stop

		//вектор вещественных - vDouble4, который является копией элементов
		// [2,5) вектора vDouble3. 

	vector<double>vDouble4(vDouble3.begin() + 2, vDouble3.end());
	printVector(vDouble4);
	stop

		//вектор элементов типа Point - vPoint1 а) с начальным размером 3. Какой конструктор
		//будет вызван для каждого элемента?
		//b) vPoint2 с начальным размером 5 и проинициализируйте каждый элемент координатами (1,1).

	vector<Point>vPoint1(3);
	printVector(vPoint1);
	vector<Point>vPoint2(5, { 1,1 });
	printVector(vPoint2);
	stop
		//вектор указателей на Point - vpPoint с начальным размером 5
		//Подумайте: как корректно заставить эти указатели "указывать" на объекты Point
	{
	vector<Point*>vpPoint(5);
	vector<Point*>::iterator it = vpPoint.begin();
	vector<Point*>::iterator itend = vpPoint.end();
	for (it; it != itend; ++it) *it = new Point;
	printVector(vpPoint);
	for (it=vpPoint.begin(); it != itend; ++it) delete *it;
	stop
	//Подсказка: для вывода на печать значений скорее всего Вам понадобится
		//а) специализация Вашей шаблонной функции
		//б) или перегрузка operator<< для Point*

	}//Какие дополнительные действия нужно предпринять для такого вектора?


	///////////////////////////////////////////////////////////////////////
	//Резервирование памяти.
	//Подумайте, всегда ли верны приведенные ниже проверки?
		
	{
		size_t n = 10;
		vector<int> v(n);
		v.resize(n/2);
		if (v.capacity() == n) cout<<"\ncapacity is the same!\n";//true?
		printVector(v);
	}
		
	{
		int n=10;
		size_t m = 20;
		vector<int> v(n);
		v.reserve(m);
		if (v.capacity() == m) cout << "\ntrue";
		printVector(v);
	}
		
	{
		vector<int> v(3,5);
		printVector(v);
		v.resize(4,10); //значения?
		printVector(v);
		v.resize(5); //значения?
		printVector(v);
	}

	//Создайте два "пустых" вектора с элементами
	//любого (но одного и того же типа) типа. 
	//В первом векторе зарезервируйте память под 5 элементов, а потом заполните
	//его значениями с помощью push_back.
	//Второй вектор просто заполните значениями посредством push_back.
	//
	cout << "\nСравните размер, емкость векторов и значения элементов\n";

	vector<int>v1;
	vector<int>v2;
	v1.reserve(5);
	for (size_t i = 0; i < 5;i++) v1.push_back(rand() % 10);
	printVector(v1);
	for (size_t i = 0; i < 5; i++) v2.push_back(rand() % 10);
	printVector(v2);

	//!!! shrink_to_fit - Уменьшение емкости вектора.
	//Для любого вектора из предыдущего задания требуется уменьшить емкость
	//до size.

	v2.shrink_to_fit();
	printVector(v2);
	
	//Создание "двухмерного вектора" - вектора векторов
	//Задан одномерный массив int ar[] = {11,2,4,3,5};
	int ar[] = { 11,2,4,3,5 };
	//Создайте вектор векторов следующим образом:
	//вектор vv[0] - содержит 11 элементов со значением 11
	//vv[1] - содержит 2,2
	//vv[2] - содержит 4,4,4,4
	//...
	//Распечатайте содержимое такого двухмерного вектора по строкам
	//с помощью:
	
	vector<vector<int>>vv(sizeof(ar) / sizeof(ar[0]));
	for (size_t i = 0; i < sizeof(ar) / sizeof(ar[0]); i++) 
		vv[i].resize(ar[i], ar[i]);

	/*for (size_t i = 0; i < sizeof(ar) / sizeof(ar[0]); i++) 
		printVector(vv[i]);*/
	std::cout<<endl<<"<< vetcor out"<<endl << vv ;
	stop

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			//Вставка элемента последовательности insert().
			//Реализуйте функцию, которая должна вставлять новый элемент
				//в начало вектора только при условии, что в векторе такого
				 //значения еще нет.
			//Проверьте работоспособность функции - в вектор vChar2 вставьте в начало вектора символ только при
			//условии, что в векторе такого символа еще нет.
				 //например: vChar2 - abc 
				 //При попытке вставить 'a' попытка должна быть проигнорирована
				 //При попытке вставить 'q' vChar2 - qabc 
	vector<char>vChar2 = {'a','b','c'};
	printVector(vChar2);
	unic_push(vChar2, 'a');
	printVector(vChar2);
	unic_push(vChar2, 'q');
	printVector(vChar2);
	//Реализуйте функцию, которая должна вставлять новый элемент
		 //перед каждым элементом вектора
	//Проверьте работоспособность функции - вставьте перед каждым элементом вектора vChar2 букву 'W'
	push_for_all(vChar2, 'W');
	printVector(vChar2);


///////////////////////////////////////////////////////////////////
	//Напишите функцию, которая должна удалять только повторяющиеся последовательности.
	//Например: было - "qwerrrrty12222r3", стало - "qwety1r3"
	string st = "qqwerrrrty12212233";
	vector<char>vChar3(st.begin(), st.end());
	printVector(vChar3);
	delete_not_unic_sequence(vChar3);
	printVector(vChar3);

	stop

		///////////////////////////////////////////////////////////////////

			//Удаление элемента последовательности erase()
			//Напишите функцию удаления из любого вектора всех дублей 
				 //Например: было - "qwerrrrty12222r3", стало - "qwerty123"

	st = "qwerrrrty12222r3";
	vChar3.assign(st.begin(),st.end());
	printVector(vChar3);
	make_unic_vect(vChar3);
	printVector(vChar3);
	

///////////////////////////////////////////////////////////////////
	//Создайте новый вектор таким образом, чтобы его элементы стали
	//копиями элементов любого из созданных ранее векторов, но расположены
	//были бы в обратном порядке
	vector<char>vChar1(vChar3.rbegin(), vChar3.rend());
	printVector(vChar1);





///////////////////////////////////////////////////////////////////

	//Задание 1. Списки. Операции, характерные для списков.
	//Создайте пустой список из элементов Point - ptList1 и наполните
	//его значениями с помощью методов push_back(),
	//push_front, insert()
	list<Point> ptList1;
	ptList1.push_back({ 0,1 });
	ptList1.push_front({ 1,1 });
	ptList1.insert(++ptList1.begin(), { 2,2 });

	//Напишите шаблон функции, которая будет выводить элементы
	//ЛЮБОГО КОНТЕЙНЕРА на печать. Проверьте работу шаблона на контейнерах
	//vector и list. Подсказка - хотелось бы увидеть тип контейнера.


	//Сделайте любой из списков "реверсивным" - reverse()


	//Создайте список ptList2 из элементов Point таким образом, чтобы он стал 
	//копией вектора элементов типа Point, но значения элементов списка располагались
	//бы в обратном порядке 



	//Отсортируйте списки  ptList1 и ptList2 - методом класса list - sort()
	//по возрастанию.
	//Подумайте: что должно быть перегружено в классе Point для того, чтобы
	//работала сортировка


	


	stop

	//Объедините отсортированные списки - merge(). Посмотрите: что
	//при этом происходит с каждым списком.

	
	stop

	//Исключение элемента из списка - remove()
	//Исключите из списка элемент с определенным значением.
	//Подумайте: что должно быть перегружено в классе Point?
	

	//Исключение элемента из списка, удовлетворяющего заданному условию:
	//любая из координат отрицательна - remove_if(). 


	//Исключение из списка подряд расположенных дублей - unique(). 

	stop

///////////////////////////////////////////////////////////////////
	//Задание 2.Очередь с двумя концами - контейнер deque

	//Создайте пустой deque с элементами типа Point. С помощью
	//assign заполните deque копиями элементов вектора. С помощью
	//разработанного Вами в предыдущем задании универсального шаблона
	//выведите значения элементов на печать



	//Создайте deque с элементами типа MyString. Заполните его значениями
	//с помощью push_back(), push_front(), insert()
	//С помощью erase удалите из deque все элементы, в которых строчки
	//начинаются с 'A' или 'a'




	return 0;
}